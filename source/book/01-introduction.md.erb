---
title: Introduction
complete: 50
date: 0001/01/01
---

<% note do %>

### A few notes before you get started.

- This preview copy is strictly personal. If you know somebody else who you think might be a good beta reader and would like to share the book with them, please <a href="mailto:info@sachagreif.com">get in touch with us</a> first. And obviously, please don't share this link on Twitter, Facebook, etc.
- Throughout the book, you'll find commit markers. While they don't do anything right now, eventually they'll be linked to the relevant commit in [this GitHub repo](https://github.com/SachaG/Microscope). For now, you'll just have to use the commit messages to help you find the right commit manually.
- By signing up at [AnnotateIt.org](http://annotateit.org), you'll be able to leave annotation anywhere in the book. Once you have an account, just select some text to get started.
- You can also use the comment form at the bottom of each chapter to leave more general comments on a chapter.
- And of course, you can always <a href="mailto:info@sachagreif.com">email us</a> with questions/remarks/anything. 

Thanks for being an early reader, and we hope you enjoy the book!

*Sacha & Tom*

<% end %>


## Introduction

Do a little mental experiment for me. Imagine you're opening the same folder in two different windows on your computer. 

Now click inside one of the two windows and delete a file. Did the file disappear from the other window as well?

You don't need to actually do these steps to know that it did. When we modify something on our local filesystems, the change gets applied everywhere without the need for refreshes or callbacks. It just happens. 

But let's think about how the same scenario would play out on the web. For example, let's say you opened the same WordPress site admin in two browser windows and then created a new post it one. 

Unlike on the desktop, no matter how long you wait the other window won't reflect the change unless you refresh it. 

Over the years, we've gotten used to the idea that a website is something that you only communicate with in short, separate bursts. 

But Meteor is part of a new wave of frameworks and technologies that are looking to challenge this status quo by making the web real-time and reactive.

### What is Meteor?

Meteor is a platform built on top of Node.js for building real-time web apps. It's what sits between your app's database and its user interface and makes sure that both are kept in sync.

Since it's built on Node.js, Meteor uses JavaScript both on the client and on the server. What's more, Meteor is also able to share code between both environments. 

The result of all this is a platform that manages to be both very powerful and very simple by abstracting away a lot of the usual hassles and pitfalls of web app development.

### Why Meteor?

So why should you spend your time learning Meteor rather than another web framework? Leaving aside all the various features of Meteor, we believe it boils down to one thing: Meteor is easy to learn.

More than any other framework, Meteor makes it possible to get a simple web app up and running on the web in a matter of hours. And if you've ever done front-end development before, you'll already be familiar with JavaScript and won't even need to learn a new language.

So Meteor might be the ideal framework for your needs, or it might not. But since you can get started over the course of a few evenings or a week-end, why not find out for yourself?

### What we're building

In this book, we'll walk you through building a full-fledged Meteor app step by step, starting from scratch.

The app we're building is a forum where people can post links as well as upvote and comment on them (think Reddit or Hacker News). 

We picked this concept because it's a simplified version of [Telescope](http://telesc.pe), our own open-source app. 

But it's also a very good excuse to address all the different elements that go into building most Meteor apps, such as user accounts, Meteor collections, routing, and more. 

### How to use this book

We wanted this book to be useful both for the novice Meteor user and the advanced programmer, so we split the chapters into two categories: regular chapters and sidebars.

Regular chapters will walk you through building the app, and will try to get you operational as soon as possible by explaining the necessary steps without bogging you down with too much detail.

On the other hand, sidebars will go deeper into Meteor's intricacies, and will help you get a better understanding of what's really going on behind the scenes.

If you're a beginner, feel free to skip the sidebars on your first read, and come back to them later on once you've played around with Meteor. 

And if you're more advanced, even if the patterns covered in the regular chapters feel familiar we're willing to bet you'll learn a thing or two from the sidebars. 