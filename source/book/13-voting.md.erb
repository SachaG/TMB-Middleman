---

title: Voting
complete: 80
date: 0013/01/01
---

## Voting

<% chapter do %>
#### In this chapter, we'll:

- Build a system where users can vote on posts.
- Rank our front page posts by vote.
- Learn how to write a general handlebars helper.
- Learn a little more about data security in Meteor.
- Cover some interesting performance considerations in MongoDB.
<% end %>

Now we have a discussion starting around our posts, it's important that people can find the most interesting posts to discuss. As such, we need some kind of ranking system to order our post with. Although we can get complex with karma, and time-based decay of rank and many other things (and Telescope indeed does some of this), for MiniScope we won't get too complex, and we'll just rate posts by the *number of votes* they receive.

To do so, we'll need to let users vote on posts though. So let's get to it.

### Data model

We'll store a list of upvoters on each post so we know whether to show the upvote button to users and to stop people from voting twice. For now, we'll publish this list of upvoters in it's entirety to all users, but it's important to think about whether you should really do this (for instance, you might not want to let people find out which users have voted for their posts, even if they look in the console).

We'll also denormalize the total number of upvoters on a post, for ease of usage. So, we'll be adding two attributes to our posts, `upvoters` and `votes`. Let's start by making sure they are initialized when posts are created:

```js
Meteor.methods({
  post: function(post) {
    var user = Meteor.user(),
      ....
    
    // pick out the whitelisted keys
    post = _.extend(_.pick(post, 'url', 'title', 'message'), {
      userId: user._id, 
      author: user.username, 
      submitted: new Date().getTime(),
      upvoters: [], votes: 0
    });
    
    return Posts.insert(post);
  }
  ...
});
```
<%= caption "lib/collections.js" %>


### Building out Voting Templates

First off, we add a up-vote button to our post partial, so wherever renders, people can click the button:
```html
<template name="post">
  ...
  <p>{{votes}} Votes <a href="#" class="upvote">⬆<a/></p>
  ...
</template>
```
<%= caption "client/views/posts/post.html" %>

Next, we'll call a server upvote method when the user clicks on the button.

```js
Template.post.events({
  'click .upvote': function() {
    Meteor.call('upvote', this._id);
  }
})
```
<%= caption "client/views/posts/post.js" %>

```js
Meteor.methods({
  upvote: function(postId) {
    var user = Meteor.user();
    // ensure the user is logged in
    if (!user)
      throw new Meteor.Error(401, "You need to login to upvote");
    
    var post = Posts.findOne(postId);
    if (!post)
      throw new Meteor.Error(422, 'Post not found');
    
    if (_.include(post.upvoters, user._id))
      throw new Meteor.Error(422, 'Already upvoted this post');
    
    Posts.update(post._id, {
      $addToSet: {upvoters: user._id},
      $inc: {votes: 1}
    });
  }
});
```
<%= caption "lib/collections.js" %>

The method is fairly straightforward. We do some defensive checks, that the user is logged in and that the post exists. Then we double check that the user hasn't already voted for the post, and if not, we increment the vote's total score and add the user to the set of upvoters.

This final step is interesting--we've used a couple of special mongo operators. There are many more to learn, but these two are extremely helpful--`$addToSet` adds an item to an array property as long as it doesn't already exist, and `$inc` simple increments an integer field.


### Displaying posts in order

The point of all this is to display the posts in the right order, so let's change the `posts` controller to return the posts in the right order. To do so, we'll use the mongo `sort` operator:

```js
Template.posts.helpers({
  posts: function() {
    return Posts.find({}, {sort: {votes: -1}});
  }
});
```
<%= caption " client/views/posts/posts_top.js" %>

Give it a try. Signup up for a few accounts in a few anonymous browser tabs, vote for some posts, and see if you can watch the order of the posts change, instantly across all browsers. Pretty cool!

Actually having posts change order instantly isn't ideal, as it's if you blink you might miss it! In the next chapter, we'll *animate* the posts when they change position, and hopefully make things much clearer. In the meantime, there are a few improvements we can make.

### Cleaning up

First off, we don't want to display an upvote button if the user isn't logged in, or if they've already voted for it. After all, they can't vote!

```html
<template name="post">
  <p>{{votes}} Votes 
    {{#if currentUserNotVoted}}
      <a href="#" class="upvote">⬆<a/>
    {{/if}}
  </p>
</template>
```
<%= caption " client/views/posts/post.html" %>

```js
Template.posts.helpers({
  currentUserNotVoted: function() {
    var userId = Meteor.userId()
    return userId && ! _.include(this.upvoters, userId);
  }
});
```
<%= caption " client/views/posts/post.js" %>

Next, you may notice that posts with a single vote are titled "1 votes". We need to pluralize properly. Pluralization is a complicated process, but for now we'll do it in a fairly simplistic way. However, we'll make a general handlebars helper to do so that we can use everywhere:

```js
Handlebars.registerHelper('pluralize', function(n, thing) {
  // fairly stupid pluralizer
  if (n === 1) {
    return '1 ' + thing;
  } else {
    return n + ' ' + thing + 's';
  }
});
```
<%= caption " client/lib/helpers.js" %>

The helpers we've made before have been tied to the controller and template that they apply to. By using `Handlebars.registerHelper`, we've created a general helper that can be used within any template. Our helper expects two arguments, so let's use it:

```html
<template name="post">
  <p>{{pluralize votes "Vote"}}
    {{#if currentUser}}
      <a href="#" class="upvote">⬆<a/>
    {{/if}}
  </p>
</template>
```
<%= caption " client/views/posts/post.html" %>

Now we should see "1 vote". Better.

### Smarter voting algorithm

Our upvoting code is pretty solid now, but there is one problem. In the upvote method, we make two calls to mongo--one grab the post, and then another to update it. 

There's two issues with this. Firstly, it's inefficient to go to the database twice (on the server); but more importantly, it introduces a race condition. We are following the following algorithm:

1. Grab the post from the database.
2. Check if the user has voted.
3. If not, do a vote by the user.

What if the same voter votes for the post in between steps 1 and 3? Then it's possible the user could vote for the same post twice. Thankfully, Mongo allows us to be smarter, and combine steps 1-3 into a single Mongo command:

```js
Meteor.methods({
  ...
  upvote: function(postId) {
    var user = Meteor.user();
    // ensure the user is logged in
    if (!user)
      throw new Meteor.Error(401, "You need to login to upvote");
    
    Posts.update({
      _id: postId, 
      upvoters: {$ne: user._id}
    }, {
      $addToSet: {upvoters: user._id},
      $inc: {votes: 1}
    });
  }
});
```
<%= caption " lib/collections.js" %>

What are saying is "find all the posts with this `id` that this user hasn't yet voted for, and update them in this way". If the user hasn't yet voted, it will of course find the post with that `id`. If the user _has_ voted, then the query will match no documents, and consequently nothing will happen.

The only downside of this, is that we can't now tell the user that they've already voted for the post. But they should know this anyway!

### Stopping cheating

If you've been paying attention, and you are quick on your feet, you may have realized a flaw in our system. What's to stop a user from tweaking the total number of votes on one of their posts? Give it a try: figure out the `id` of one of your own posts (preferably one that's languishing at the bottom of the post list), and try a little hack:

```js
  Posts.update(postId, {$set: {votes: 10000}});
```
<%= caption " browser console" %>

How are we allowed to do this? Well, when we specified the `allow` rules for updating posts, we only said that a user can only edit *their own posts*, but never anything about *how*! 

Luckily, the problem is easily solved with the addition of a `deny` rule:
```js
  Posts.deny({
    update: function(userId, doc, fields) {
     return _.contains(fields, 'votes') || _.contains(fields, 'upvoters');
  });
```
<%= caption " lib/posts.js" %>

An `update` rule receives as third argument a set of the fields that are going to be modified. We simply take a look to see if `votes` or `upvoters` are included there, and return `true` (i.e. that we should deny this change) if so.

Considering that our edit post form never touches those fields, we've solved the problem nicely. Try the little hack again on another one of your posts:

```js
  Posts.update(postId, {$set: {votes: 10000}});
  >> SOME ERROR MESSAGE
```
<%= caption " browser console" %>

<% note do %>
#### Latency compensation

If you looked carefully, you'll have seen latency compensation in action. It may not have been visible, but you may have seen the post jump to the top of the list briefly, before shooting back into position. 

What's happened? In your local `Posts` collection, the `update` was applied without incident. This happens instantly, so the post shot to the top of the list. Meanwhile, on the server, the `update` was being denied. So some time later (measured in the milliseconds if you are running Meteor on your own machine), the server returned an error, telling the local collection to revert itself. The end result--exactly what we'd expect.
<% end %>


### Ranking the front page posts by number of votes

XXX: Do this once pagination has been worked out

### A Better Header

Now that we have two post list pages, it can be hard to know just which list you're currently viewing. So let's revisit our header to reflect that. Let's create a `header.js` controller and use a bit of jQuery magic to highlight the current page:

```js
Template.header.rendered = function(){
  $(this.firstNode).find(".nav>li").each(function(){
    if($(this).children("a").attr("href") === window.location.pathname)
      $(this).addClass("active");
  });
}
```

`this.firstNode` gives us the DOM element corresponding to our current template instance, and wrapping it in the jQuery object (`$()`) lets us iterate over all its `<li>` elements. We then simply compare the link's `href` attribute to the current URL path, and if they match we add an `active` class to the `<li>`. 